<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vihan's 3D Racer - Customize!</title>
    <style>
        /* --- General --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #a0d7e6;
            font-family: sans-serif;
            overscroll-behavior: none;
            touch-action: none;
        }
        canvas {
            display: block;
        }

        /* --- Buttons --- */
        .game-button { /* Common styles for start, restart, pause, resume */
            padding: 15px 30px;
            font-size: 1.8em;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            text-align: center;
            min-width: 150px; /* Ensure buttons have some width */
        }
        #start-button { background-color: #4CAF50; /* Green */ }
        #restart-button { background-color: #ff9800; /* Orange */ }
        #resume-button { background-color: #2196F3; /* Blue */ margin-top: 20px; }
        #pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            font-size: 1.1em;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            z-index: 70;
            cursor: pointer;
            display: none; /* Hidden initially */
        }
        #pause-button:hover { background-color: rgba(0, 0, 0, 0.7); }


        /* --- Loading & Start --- */
        #loading-screen {
            position: absolute; width: 100%; height: 100%; background-color: #000; color: white;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            font-size: 1.5em; text-align: center; z-index: 100; opacity: 1; transition: opacity 0.5s ease-out;
        }
        #loading-screen.hidden { opacity: 0; pointer-events: none; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 90; display: none; /* Start hidden */
            color: white; text-align: center; padding: 20px; box-sizing: border-box;
        }
        #garage-placeholder { margin-top: 15px; font-size: 1em; color: #aaa; }

        /* --- Pause Screen --- */
        #pause-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 95; /* Above game, below loading */
            display: none; /* Hidden initially */
            color: white; text-align: center; padding: 20px; box-sizing: border-box;
        }
        #pause-screen h2 { margin-bottom: 25px; font-size: 2.5em; }


        /* --- Color Selector (Used in Start and Pause) --- */
        #color-selector { margin: 20px 0; }
        #color-selector p { margin-bottom: 10px; font-size: 1.2em; }
        .color-button {
            width: 40px; height: 40px; border: 2px solid white; border-radius: 50%;
            display: inline-block; margin: 0 5px; cursor: pointer;
            transition: transform 0.1s ease-out; vertical-align: middle;
        }
        .color-button:hover, .color-button.selected { transform: scale(1.1); border-width: 3px; }

        /* --- In-Game UI --- */
        #ui-container {
            position: absolute; top: 10px; left: 10px; color: white;
            text-shadow: 1px 1px 3px black; z-index: 50; font-size: 1.3em;
            background-color: rgba(0,0,0,0.2); padding: 5px 10px; border-radius: 5px;
            display: none; /* Hidden initially */
        }
        #score { margin-bottom: 5px; }
        #level { margin-bottom: 5px; }

        #tips-area {
            position: absolute; bottom: 110px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 400px; text-align: center; font-size: 1em; color: white;
            text-shadow: 1px 1px 2px black; background-color: rgba(0,0,0,0.3); padding: 5px;
            border-radius: 5px; z-index: 55; opacity: 0; transition: opacity 0.5s ease-in;
            display: none; pointer-events: none;
        }

        #vihan-message {
            position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
            padding: 15px 25px; background-color: rgba(0, 0, 0, 0.7); color: #ffcc00;
            font-size: 1.8em; font-weight: bold; text-align: center; border-radius: 10px;
            z-index: 101; display: none; opacity: 0; transition: opacity 0.5s ease-out;
            pointer-events: none;
        }

        /* --- Game Over Screen --- */
        #game-over-screen { /* Renamed container */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Overlay */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 101; /* Above everything */
            display: none; /* Hidden initially */
            text-align: center;
            color: white; /* General text color for this screen */
        }
        #game-over-title {
            color: #ff4444; font-size: 3.5em; font-weight: bold;
            text-shadow: 2px 2px 5px black;
        }
        #game-over-message { /* Vihan's crash message */
             font-size: 1.5em; /* Larger than before */
             color: #ffddaa;
             margin-top: 15px;
             margin-bottom: 30px; /* Space before button */
        }
        #restart-button { /* Style defined above in .game-button */
            display: block; /* Make it visible when screen shows */
        }


        /* --- Mobile Control Buttons --- */
        .control-button {
            position: absolute; bottom: 20px; width: 80px; height: 80px;
            background-color: rgba(255, 255, 255, 0.3); border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%; z-index: 60; display: flex; justify-content: center;
            align-items: center; font-size: 2.5em; color: rgba(0, 0, 0, 0.7); cursor: pointer;
            user-select: none; -webkit-user-select: none; -ms-user-select: none; -moz-user-select: none;
            -webkit-tap-highlight-color: transparent; display: none; /* Initially hidden */
        }
        .control-button:active { background-color: rgba(255, 255, 255, 0.5); }
        #left-button { left: 20px; }
        #right-button { right: 20px; }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">Loading Assets...</div>

    <!-- Start Screen (Shown After Loading) -->
    <div id="start-screen">
        <h1>Vihan's 3D Racer</h1>
        <!-- Color Selector initially here -->
        <div id="start-color-selector">
             <p>Choose Your Car Color:</p>
             <!-- Color buttons will be added here by JS -->
        </div>
        <button id="start-button" class="game-button">Start Race!</button>
        <div id="garage-placeholder">Garage & Upgrades (Coming Soon!)</div>
    </div>

     <!-- Pause Screen -->
    <div id="pause-screen">
        <h2>PAUSED</h2>
        <!-- Color Selector moved here for pausing -->
        <div id="pause-color-selector">
            <p>Change Car Color:</p>
             <!-- Color buttons will be added here by JS -->
        </div>
        <button id="resume-button" class="game-button">Resume</button>
    </div>

    <!-- Main Game Container -->
    <div id="container"></div>

    <!-- In-Game UI Elements -->
    <div id="ui-container">
        <div id="score">Score: 0</div>
        <div id="level">Level: 1</div>
    </div>
    <button id="pause-button">Pause (P)</button> <!-- Pause Button -->
    <div id="tips-area"></div> <!-- Rotating Tips -->
    <div id="vihan-message"></div> <!-- Level Up / Win Messages -->

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <div id="game-over-title">GAME OVER!</div>
        <div id="game-over-message"></div> <!-- Vihan's Crash Message -->
        <button id="restart-button" class="game-button">Restart</button>
    </div>


    <!-- Mobile Control Buttons -->
    <div id="left-button" class="control-button">◀</div>
    <div id="right-button" class="control-button">▶</div>


    <!-- Import Maps for Three.js Modules -->
     <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // --- Constants ---
        const roadWidth = 10;
        const roadLength = 200;
        const buildingSpacing = 15;
        const lightSpacing = 30;
        const kerbHeight = 0.2;
        const kerbWidth = 0.3;
        const numPoints = 50;
        const pointValue = 10;
        const pointRadius = 0.3;
        const carMoveSpeed = 0.15;
        const baseDriveSpeed = 0.4;
        const speedIncrement = 0.05;
        const levelScoreThreshold = 200;
        const scoreThresholdIncrement = 250;
        const enemiesPerLevel = 1;
        const maxTotalEnemies = 5;
        const baseEnemySpeed = 0.35;
        const enemySpeedVariance = 0.1;
        const tipsIntervalDuration = 5000;
        const vihanMessageDuration = 3000;
        const musicVolume = 0.3;

         // --- Vihan's Messages & Tips ---
        const crashMessages = [
            "Oops! Vihan says: Even Ferraris need brakes!",
            "Woah there! Vihan thinks you confused the pedal with the eject button.",
            "Crash! Vihan asks: Did the other car forget to signal?",
            "Boom! Vihan's diagnosis: Sudden unplanned disassembly.",
            "Ouch! Vihan advises: Maybe stick to the virtual lanes next time?",
            "Kerpow! Vihan heard that one! Try again!",
        ];
        const positiveMessages = [
            "Nice! Vihan sees potential!", "Level Up! Vihan is impressed!",
            "Awesome driving! Vihan gives you a virtual high-five!",
            "You're getting faster! Vihan approves!", "Sweet moves! Vihan says: Keep it up!",
        ];
        const tips = [
            "Tip: Collect yellow orbs for points!", "Tip: Avoid the blue cars!",
            "Tip: Use Left/Right arrows or tap screen sides to steer.",
            "Tip: Score more points to level up and go faster!",
            "Tip: The red/white kerbs mark the road edge.", "Tip: Vihan designed this road himself!",
            "Tip: Press 'P' or the button to Pause/Change Color.", // New Tip
        ];
        const carColors = [
            { name: 'Red', hex: 0xff0000 }, { name: 'White', hex: 0xffffff },
            { name: 'Black', hex: 0x111111 }, { name: 'Yellow', hex: 0xffdd00 },
            { name: 'Green', hex: 0x00cc44 }, { name: 'Pink', hex: 0xff69b4 },
            { name: 'Blue', hex: 0x0077ff },
        ];


        // --- State Variables ---
        let scene, camera, renderer, carModel, carPlaceholder;
        let ambientLight, directionalLight;
        let roadLines = [], kerbs = [], buildings = [], streetLights = [], trafficLights = [], points = [];
        let enemyCars = [], enemyCarTemplate;
        let moveLeft = false, moveRight = false;
        let carBaseY = 0, enemyBaseY = 0;
        let score = 0, currentLevel = 1, currentLevelScoreThreshold = levelScoreThreshold;
        let isGameOver = false, gameStarted = false, isPaused = false; // Added isPaused
        let driveSpeed = baseDriveSpeed;
        let maxActiveEnemies = 1;
        let tipsIntervalId = null, currentTipIndex = 0;
        let selectedColorHex = carColors[0].hex;
        let vihanMessageTimeoutId = null;
        let animationFrameId = null;

        // --- Audio Variables ---
        let audioCtx = null, audioInitialized = false;
        let backgroundMusicBuffer = null;
        let backgroundMusicSource = null;
        let backgroundMusicGain = null;


        // --- Bounding Boxes ---
        let playerBox = new THREE.Box3();
        let enemyBox = new THREE.Box3();
        let pointBox = new THREE.Box3();

        // --- UI Refs ---
        const loadingScreen = document.getElementById('loading-screen');
        const startScreen = document.getElementById('start-screen');
        const pauseScreen = document.getElementById('pause-screen'); // New Ref
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button'); // New Ref
        const pauseButton = document.getElementById('pause-button'); // New Ref
        const resumeButton = document.getElementById('resume-button'); // New Ref
        const startColorSelectorDiv = document.getElementById('start-color-selector'); // Specific ID
        const pauseColorSelectorDiv = document.getElementById('pause-color-selector'); // Specific ID
        const gameContainer = document.getElementById('container');
        const uiContainer = document.getElementById('ui-container');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const tipsArea = document.getElementById('tips-area');
        const vihanMessageArea = document.getElementById('vihan-message');
        const gameOverScreen = document.getElementById('game-over-screen'); // Renamed Ref
        const gameOverMessageElement = document.getElementById('game-over-message');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');

        // --- Loading Manager ---
        const loadingManager = new THREE.LoadingManager();
        loadingManager.onLoad = () => {
            console.log("All resources loaded!");
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                 loadingScreen.style.display = 'none';
                 startScreen.style.display = 'flex';
            }, 500);
        };
        loadingManager.onError = (url) => { console.error(`Error loading ${url}`); loadingScreen.textContent = `Error loading assets. Check console (F12) & network.`; };
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => { loadingScreen.textContent = `Loading ${Math.round((itemsLoaded / itemsTotal) * 100)}%...`; };


        // --- Initialize ---
        init();

        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame); // New Listener
        pauseButton.addEventListener('click', togglePause);     // New Listener
        resumeButton.addEventListener('click', togglePause);    // New Listener (uses same toggle function)
        window.addEventListener('resize', onWindowResize, false);


        // --- Initialization Functions ---
        function init() {
            setupScene();
            setupLighting();
            createWorldElements();
            createPoints();
            createCarColorSelector(startColorSelectorDiv); // Create for start screen
            createCarColorSelector(pauseColorSelectorDiv);  // Create for pause screen
            loadModels();
            loadAudio();
            updateScoreDisplay();
            updateLevelDisplay();
            // Hide elements that shouldn't be visible yet
            pauseButton.style.display = 'none';
            pauseScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            uiContainer.style.display = 'none';
            leftButton.style.display = 'none';
            rightButton.style.display = 'none';
            tipsArea.style.display = 'none';
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6);
            scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            gameContainer.appendChild(renderer.domElement);
        }

        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.8); directionalLight.position.set(50, 100, 50); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 500; directionalLight.shadow.camera.left = -roadLength / 2; directionalLight.shadow.camera.right = roadLength / 2; directionalLight.shadow.camera.top = roadLength / 2; directionalLight.shadow.camera.bottom = -roadLength / 2; scene.add(directionalLight);
        }

        function createWorldElements() {
            // Ground, Road, Road Lines, Kerbs, Buildings, Lights... (Keep this code as is)
            // Ground
            const groundGeo = new THREE.PlaneGeometry(roadLength * 1.5, roadLength); const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, side: THREE.DoubleSide }); const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI / 2; ground.position.y = -0.05; ground.receiveShadow = true; scene.add(ground);
            // Road
            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength); const roadMat = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide }); const road = new THREE.Mesh(roadGeo, roadMat); road.rotation.x = -Math.PI / 2; road.position.y = 0.0; road.receiveShadow = true; scene.add(road);
            // Road Lines
            const lineLength = 4; const lineGap = 4; const numLines = Math.floor(roadLength / (lineLength + lineGap)); const lineGeo = new THREE.PlaneGeometry(0.3, lineLength); const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            roadLines = []; // Clear array before populating (important for restart)
            for (let i = 0; i < numLines; i++) { const line = new THREE.Mesh(lineGeo, lineMat); line.rotation.x = -Math.PI / 2; line.position.y = 0.005; line.position.z = (roadLength / 2) - (lineLength / 2) - i * (lineLength + lineGap); line.receiveShadow = true; roadLines.push(line); scene.add(line); }
            // Kerbs
            function createKerbTexture() { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 64; canvas.height = 16; const stripeWidth = 8; const colors = ['#ff0000', '#ffffff']; for (let i = 0; i < canvas.width / stripeWidth; i++) { ctx.fillStyle = colors[i % 2]; ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height); } return new THREE.CanvasTexture(canvas); }
            const kerbTexture = createKerbTexture(); kerbTexture.wrapS = THREE.RepeatWrapping; kerbTexture.wrapT = THREE.ClampToEdgeWrapping; kerbTexture.repeat.set(roadLength / 4, 1);
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, kerbHeight, roadLength); const kerbMat = new THREE.MeshStandardMaterial({ map: kerbTexture });
            kerbs = []; // Clear array
            const kerbLeft = new THREE.Mesh(kerbGeo, kerbMat); kerbLeft.position.set(-(roadWidth / 2) - (kerbWidth / 2), kerbHeight / 2, 0); kerbLeft.castShadow = true; kerbLeft.receiveShadow = true; scene.add(kerbLeft); kerbs.push(kerbLeft);
            const kerbRight = new THREE.Mesh(kerbGeo, kerbMat); kerbRight.position.set((roadWidth / 2) + (kerbWidth / 2), kerbHeight / 2, 0); kerbRight.castShadow = true; kerbRight.receiveShadow = true; scene.add(kerbRight); kerbs.push(kerbRight);
            // Buildings
            function createBuilding() { const height = Math.random() * 30 + 10; const width = Math.random() * 8 + 4; const depth = Math.random() * 8 + 4; const buildingGeo = new THREE.BoxGeometry(width, height, depth); const buildingMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(Math.random() * 0.8 + 0.1, Math.random() * 0.8 + 0.1, Math.random() * 0.8 + 0.1), roughness: 0.8, metalness: 0.1 }); const building = new THREE.Mesh(buildingGeo, buildingMat); building.position.y = height / 2; building.castShadow = true; building.receiveShadow = true; return building; }
            const numBuildings = Math.floor(roadLength / buildingSpacing);
            buildings = []; // Clear array
            for (let i = 0; i < numBuildings; i++) { const buildingLeft = createBuilding(); const buildingRight = createBuilding(); const zPos = (roadLength / 2) - (buildingSpacing / 2) - i * buildingSpacing; const xOffsetLeft = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingLeft.geometry.parameters.width / 2; const xOffsetRight = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + buildingRight.geometry.parameters.width / 2; buildingLeft.position.set(-xOffsetLeft, buildingLeft.position.y, zPos); buildingRight.position.set(xOffsetRight, buildingRight.position.y, zPos); buildings.push(buildingLeft, buildingRight); scene.add(buildingLeft); scene.add(buildingRight); }
            // Street Lights
            function createStreetLight() { const group = new THREE.Group(); const poleHeight = 6; const poleRadius = 0.1; const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight); const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.4 }); const pole = new THREE.Mesh(poleGeo, poleMat); pole.castShadow = true; pole.position.y = poleHeight/2; group.add(pole); const armLength = 1; const armGeo = new THREE.BoxGeometry(armLength, poleRadius * 1.5, poleRadius * 1.5); const arm = new THREE.Mesh(armGeo, poleMat); arm.position.set(0, poleHeight - poleRadius * 2, 0); group.add(arm); const lightFixtureGeo = new THREE.SphereGeometry(poleRadius * 2, 16, 8); const lightFixtureMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffff00, emissiveIntensity: 0.5 }); const lightFixture = new THREE.Mesh(lightFixtureGeo, lightFixtureMat); lightFixture.position.set(0, poleHeight - poleRadius * 2, 0); group.add(lightFixture); group.userData.armLength = armLength; return group;}
            const numLights = Math.floor(roadLength / lightSpacing);
            streetLights = []; // Clear array
            for (let i = 0; i < numLights; i++) { const lightLeft = createStreetLight(); const lightRight = createStreetLight(); const zPos = (roadLength / 2) - (lightSpacing / 2) - i * lightSpacing; const xPos = roadWidth / 2 + kerbWidth + 0.8; lightLeft.position.set(-xPos, 0, zPos); lightLeft.rotation.y = Math.PI / 2; lightLeft.children[1].position.x = -lightLeft.userData.armLength / 2; lightLeft.children[2].position.x = -lightLeft.userData.armLength; lightRight.position.set(xPos, 0, zPos); lightRight.rotation.y = -Math.PI / 2; lightRight.children[1].position.x = -lightRight.userData.armLength / 2; lightRight.children[2].position.x = -lightRight.userData.armLength; streetLights.push(lightLeft, lightRight); scene.add(lightLeft); scene.add(lightRight); }
            // Traffic Lights
            function createTrafficLight() { const group = new THREE.Group(); const poleHeight = 5; const poleRadius = 0.15; const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight); const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.5 }); const pole = new THREE.Mesh(poleGeo, poleMat); pole.position.y = poleHeight / 2; pole.castShadow = true; group.add(pole); const housingWidth = 0.5; const housingHeight = 1.2; const housingDepth = 0.3; const housingGeo = new THREE.BoxGeometry(housingWidth, housingHeight, housingDepth); const housingMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); const housing = new THREE.Mesh(housingGeo, housingMat); housing.position.y = poleHeight - housingHeight / 2; housing.castShadow = true; group.add(housing); const lightRadius = housingWidth * 0.25; const lightGeo = new THREE.SphereGeometry(lightRadius, 16, 8); const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 1 }); const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 1 }); const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 1 }); const redLight = new THREE.Mesh(lightGeo, redMat); redLight.position.set(0, housingHeight * 0.3, housingDepth / 2 + 0.01); housing.add(redLight); const yellowLight = new THREE.Mesh(lightGeo, yellowMat); yellowLight.position.set(0, 0, housingDepth / 2 + 0.01); housing.add(yellowLight); const greenLight = new THREE.Mesh(lightGeo, greenMat); greenLight.position.set(0, -housingHeight * 0.3, housingDepth / 2 + 0.01); housing.add(greenLight); return group; }
            trafficLights = []; // Clear array
            const trafficLightLeft = createTrafficLight(); const trafficLightRight = createTrafficLight(); const trafficLightZ = roadLength * 0.4; const trafficLightX = roadWidth / 2 + kerbWidth + 0.5; trafficLightLeft.position.set(-trafficLightX, 0, trafficLightZ); trafficLightLeft.rotation.y = Math.PI / 2; trafficLightRight.position.set(trafficLightX, 0, trafficLightZ); trafficLightRight.rotation.y = -Math.PI / 2; trafficLights.push(trafficLightLeft, trafficLightRight); scene.add(trafficLightLeft); scene.add(trafficLightRight);
        }

        function createPoints() {
            // Remove existing points from scene if restarting
            points.forEach(p => scene.remove(p));
            points = []; // Clear array

            const pointGeometry = new THREE.SphereGeometry(pointRadius, 8, 8);
            const pointMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaaaa00, emissiveIntensity: 0.8 });
            for (let i = 0; i < numPoints; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.castShadow = true;
                resetPointPosition(point, true); // Initial placement
                points.push(point);
                scene.add(point);
            }
        }

         // Modified to accept a target container
         function createCarColorSelector(targetDiv) {
             // Clear existing buttons in the target div first
             targetDiv.innerHTML = ''; // Clear previous buttons if any
             const p = document.createElement('p'); // Re-add the <p> text if needed
             if(targetDiv.id === 'start-color-selector') p.textContent = 'Choose Your Car Color:';
             else if(targetDiv.id === 'pause-color-selector') p.textContent = 'Change Car Color:';
             targetDiv.appendChild(p);

             carColors.forEach((colorInfo, index) => {
                 const button = document.createElement('span');
                 button.classList.add('color-button');
                 button.style.backgroundColor = `#${colorInfo.hex.toString(16).padStart(6, '0')}`;
                 button.dataset.hex = colorInfo.hex;
                 button.title = colorInfo.name;

                 // Check if this color is the currently selected one
                 if (colorInfo.hex === selectedColorHex) {
                      button.classList.add('selected');
                 }

                 button.addEventListener('click', () => {
                     selectedColorHex = parseInt(button.dataset.hex);
                      // Update visual selection in *both* selectors
                     document.querySelectorAll('.color-button').forEach(btn => {
                         btn.classList.remove('selected');
                         if (parseInt(btn.dataset.hex) === selectedColorHex) {
                             btn.classList.add('selected');
                         }
                     });
                     // If the game is running (not paused/over), apply color immediately
                     // Otherwise, it will be applied on resume/restart
                     if (gameStarted && !isPaused && !isGameOver) {
                         applyCarColor(selectedColorHex);
                     }
                 });
                 targetDiv.appendChild(button);
             });
         }

         function loadModels() {
            const loader = new GLTFLoader(loadingManager);
            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            loader.setDRACOLoader(dracoLoader);
            const carUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';

            const fallbackGeo = new THREE.BoxGeometry(2, 1, 4);
            const fallbackMat = new THREE.MeshStandardMaterial({color: 0xff0000});
            carPlaceholder = new THREE.Mesh(fallbackGeo, fallbackMat);
            carPlaceholder.visible = false; scene.add(carPlaceholder);

            loader.load(carUrl, (gltf) => {
                carModel = gltf.scene;
                carModel.scale.set(0.8, 0.8, 0.8);
                const box = new THREE.Box3().setFromObject(carModel);
                carBaseY = box.getSize(new THREE.Vector3()).y / 2 + 0.01;
                carModel.position.set(0, carBaseY, 0);
                carModel.rotation.y = Math.PI;
                scene.add(carModel);
                // --- IMPORTANT: Only add to scene ONCE ---

                enemyCarTemplate = carModel.clone();
                 enemyBaseY = carBaseY;
                 applyEnemyColor(enemyCarTemplate, 0x0000ff);
                 setupInitialCamera();
            }, undefined, (error) => {
                 console.error('Error loading car model:', error);
                 handleModelLoadError();
                 setupInitialCamera();
            });
        }

        function handleModelLoadError() {
             if (scene.children.includes(carPlaceholder)) { // Only add if not already added
                 carPlaceholder.visible = true;
             } else {
                 scene.add(carPlaceholder); // Add if it wasn't there
                 carPlaceholder.visible = true;
             }
             carModel = carPlaceholder; // Assign placeholder
             carBaseY = 0.5 + 0.01;
             carModel.position.set(0, carBaseY, 0);
             carModel.castShadow = true; carModel.receiveShadow = true;

             enemyBaseY = carBaseY;
             enemyCarTemplate = carModel.clone();
             applyEnemyColor(enemyCarTemplate, 0x0000ff);

             loadingScreen.textContent = 'Error loading car. Using fallback.';
             console.warn("Using fallback cube for car model.");
        }

         function applyCarColor(hexColor) {
            if (!carModel || !carModel.traverse) { // Basic check if model is valid
                console.warn("Cannot apply color: Car model not ready or invalid.");
                return;
            }
             if (carModel === carPlaceholder) { // Apply to placeholder material directly
                 carModel.material.color.setHex(hexColor);
                 console.log(`Applied fallback car color: #${hexColor.toString(16)}`);
                 return;
             }

            carModel.traverse((node) => {
                if (node.isMesh) {
                    if (Array.isArray(node.material)) {
                        node.material.forEach(mat => { if (mat.isMeshStandardMaterial) mat.color.setHex(hexColor); });
                    } else if (node.material?.isMeshStandardMaterial) { // Optional chaining
                        node.material.color.setHex(hexColor);
                    }
                    node.castShadow = true; node.receiveShadow = true;
                }
            });
            console.log(`Applied player car color: #${hexColor.toString(16)}`);
         }

         function applyEnemyColor(model, hexColor) {
             if (!model || !model.traverse) return;
              if (model === carPlaceholder) { // Handle fallback clone
                  model.material.color.setHex(hexColor); return;
              }
             model.traverse((node) => {
                if (node.isMesh) {
                     if (Array.isArray(node.material)) {
                         node.material.forEach(mat => { if (mat.isMeshStandardMaterial) mat.color.setHex(hexColor); });
                     } else if (node.material?.isMeshStandardMaterial) {
                         node.material.color.setHex(hexColor);
                     }
                    node.castShadow = true; node.receiveShadow = true;
                 }
             });
         }

        function setupInitialCamera() {
            if (!carModel) return;
            camera.position.set(0, carBaseY + 3, -7);
            camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
        }


        // --- Game Start / Restart Logic ---
        function startGame() {
            if (gameStarted || !carModel || !enemyCarTemplate) {
                console.warn("Cannot start game yet. Models not ready or game already started.");
                return;
            }
            console.log("Starting Game...");
            gameStarted = true;
            isGameOver = false;
            isPaused = false;

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            uiContainer.style.display = 'block';
            leftButton.style.display = 'flex';
            rightButton.style.display = 'flex';
            tipsArea.style.display = 'block';
            pauseButton.style.display = 'block'; // Show pause button
            pauseButton.textContent = "Pause (P)"; // Ensure correct text

            // Reset stats for a fresh game
            resetGameStats();

            applyCarColor(selectedColorHex); // Apply chosen color
            carModel.position.set(0, carBaseY, 0); // Ensure car starts at origin

            // Reset and spawn enemies
            clearEnemies(); // Remove any old enemies first
            spawnInitialEnemies();

            // Reset points
            createPoints(); // Recreate and position points

            getAudioContext(); // Initialize audio
            if (audioInitialized && audioCtx.state === 'running' && backgroundMusicBuffer) {
                startBackgroundMusic();
            }

            setupControls(); // Add event listeners
            startTipsRotation(); // Begin showing tips
            animate(); // Start the game loop
        }

        function restartGame() {
             console.log("Restarting Game...");
             if (!gameStarted) { // If the initial game never started, just run startGame
                 startGame();
                 return;
             }

             // Reset Flags
             isGameOver = false;
             isPaused = false;

             // Hide overlays
             gameOverScreen.style.display = 'none';
             pauseScreen.style.display = 'none';

             // Show In-Game UI
             uiContainer.style.display = 'block';
             leftButton.style.display = 'flex';
             rightButton.style.display = 'flex';
             tipsArea.style.display = 'block';
             pauseButton.style.display = 'block'; // Show pause button
             pauseButton.textContent = "Pause (P)";

             // Reset Core Game State
             resetGameStats();
             updateScoreDisplay(); // Update UI
             updateLevelDisplay();

             // Reset Player Car Position
             if (carModel) {
                 carModel.position.set(0, carBaseY, 0);
                 carModel.visible = true; // Ensure it's visible
             }

             // Reset Enemies
             clearEnemies(); // Remove existing enemies
             spawnInitialEnemies(); // Spawn new ones

             // Reset Points
             createPoints(); // Recreate points

              // Ensure correct color selector state reflects current color
             createCarColorSelector(startColorSelectorDiv);
             createCarColorSelector(pauseColorSelectorDiv);
             applyCarColor(selectedColorHex); // Re-apply color in case it changed

             // Restart Music and Tips
             if (audioInitialized && audioCtx.state === 'running' && backgroundMusicBuffer) {
                 startBackgroundMusic();
             }
             startTipsRotation();

             // Restart Animation Loop
             animate(); // Start the animation loop again
        }

        function resetGameStats() {
            score = 0;
            currentLevel = 1;
            currentLevelScoreThreshold = levelScoreThreshold;
            driveSpeed = baseDriveSpeed;
            maxActiveEnemies = 1; // Reset to starting enemy count
            moveLeft = false; // Reset movement flags
            moveRight = false;
        }

        function clearEnemies() {
             enemyCars.forEach(enemy => {
                 if (enemy) scene.remove(enemy);
             });
             enemyCars = [];
        }

        // --- Pause Logic ---
        function togglePause() {
            if (isGameOver || !gameStarted) return; // Don't pause if game over or not started

            isPaused = !isPaused;
            console.log("Pause Toggled:", isPaused);

            if (isPaused) {
                // PAUSE
                if (animationFrameId) cancelAnimationFrame(animationFrameId); // Stop game loop
                animationFrameId = null;
                stopBackgroundMusic(); // Pause music
                stopTipsRotation(); // Stop tips
                pauseScreen.style.display = 'flex'; // Show pause overlay
                pauseButton.textContent = "Resume (P)"; // Update button text
                // Update color selector on pause screen to reflect current selection
                createCarColorSelector(pauseColorSelectorDiv);
            } else {
                // RESUME
                applyCarColor(selectedColorHex); // Apply potentially changed color
                pauseScreen.style.display = 'none'; // Hide pause overlay
                pauseButton.textContent = "Pause (P)"; // Update button text
                // Resume music (ensure context is running)
                if (audioInitialized && audioCtx.state === 'running' && backgroundMusicBuffer) {
                     startBackgroundMusic();
                } else if (audioCtx && audioCtx.state === 'suspended'){
                    audioCtx.resume().then(() => { startBackgroundMusic(); }); // Try resuming context first
                }
                startTipsRotation(); // Resume tips
                animate(); // Restart game loop
            }
        }


        // --- Sound Functions ---
        function getAudioContext() { /* ... (Keep this code as is) ... */
            if (audioInitialized) return audioCtx;
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    audioInitialized = true;
                    if (audioCtx.state === 'suspended') { audioCtx.resume().catch(e => console.error("Error resuming AudioContext:", e)); }
                    console.log("AudioContext created/resumed.");
                } catch (e) { console.error("Web Audio API failed:", e); audioInitialized = false; audioCtx = null; }
            }
            return audioCtx;
        }
        function loadAudio() { /* ... (Keep this code as is) ... */
            const audioLoader = new THREE.AudioLoader(loadingManager);
            const musicFilePath = './assets/your_background_music.mp3'; // <<< CHANGE THIS PATH
            audioLoader.load( musicFilePath, (buffer) => { backgroundMusicBuffer = buffer; console.log("Music loaded"); }, undefined, (err) => { console.error(`Error loading music: ${musicFilePath}`, err); });
        }
        function startBackgroundMusic() { /* ... (Keep this code as is, ensures cleanup) ... */
            if (!audioInitialized || !audioCtx || audioCtx.state !== 'running' || !backgroundMusicBuffer) return;
            stopBackgroundMusic(); // Stop previous instance first
            backgroundMusicGain = audioCtx.createGain();
            backgroundMusicGain.gain.setValueAtTime(musicVolume, audioCtx.currentTime);
            backgroundMusicGain.connect(audioCtx.destination);
            backgroundMusicSource = audioCtx.createBufferSource();
            backgroundMusicSource.buffer = backgroundMusicBuffer;
            backgroundMusicSource.loop = true;
            backgroundMusicSource.connect(backgroundMusicGain);
            try { backgroundMusicSource.start(0); console.log("Music started."); } catch (e) { console.error("Error starting music:", e); stopBackgroundMusic(); } // Clean up if start fails
        }
        function stopBackgroundMusic() { /* ... (Keep this code as is) ... */
             if (backgroundMusicSource) {
                 try { backgroundMusicSource.stop(); console.log("Music stopped."); } catch (e) { /* ignore */ }
                 backgroundMusicSource.disconnect(); backgroundMusicSource = null;
             }
             if (backgroundMusicGain) { backgroundMusicGain.disconnect(); backgroundMusicGain = null; }
        }
        function playSound(type) { /* ... (Keep this code as is) ... */
            if (!audioInitialized || !audioCtx || audioCtx.state !== 'running') return;
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.connect(gain); gain.connect(audioCtx.destination);
            let freq, duration, waveType, vol;
            switch (type) { /* cases... */
                 case 'point': freq = 880; duration = 0.1; waveType = 'triangle'; vol = 0.2; break;
                 case 'collision': freq = 150; duration = 0.3; waveType = 'sawtooth'; vol = 0.3; break;
                 case 'levelUp': freq = 440; duration = 0.4; waveType = 'square'; vol = 0.2; break;
                 default: return;
            }
            osc.type = waveType; osc.frequency.setValueAtTime(freq, audioCtx.currentTime); gain.gain.setValueAtTime(vol, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + duration);
            if (type === 'levelUp') { /* harmony... */
                const osc2 = audioCtx.createOscillator(); osc2.connect(gain); osc2.type = waveType; osc2.frequency.setValueAtTime(freq * 1.5, audioCtx.currentTime); osc2.start(audioCtx.currentTime); osc2.stop(audioCtx.currentTime + duration);
            }
        }
        // --- End Sound Functions ---


        // --- Enemy Spawning ---
        function spawnEnemyCar() { /* ... (Keep this code as is) ... */
            if (!enemyCarTemplate) return null;
            if (enemyCars.length >= maxTotalEnemies) return null;
            const newEnemy = enemyCarTemplate.clone();
            newEnemy.userData.speed = baseEnemySpeed + (Math.random() - 0.5) * 2 * enemySpeedVariance;
            resetEnemyPosition(newEnemy, true);
            newEnemy.visible = true;
            scene.add(newEnemy); // Add to scene
            enemyCars.push(newEnemy); // Add to array
            return newEnemy;
        }
        function spawnInitialEnemies() { /* ... (Keep this code as is) ... */
            maxActiveEnemies = 1; // Ensure starts at 1 on new game/restart
            for(let i = 0; i < maxActiveEnemies; i++) { spawnEnemyCar(); }
        }
        function resetEnemyPosition(enemy, initialSpawn = false) { /* ... (Keep this code as is) ... */
             const laneWidth = roadWidth / 2 - kerbWidth - 1.0;
             enemy.position.x = (Math.random() * 2 - 1) * laneWidth * 0.8;
             enemy.position.y = enemyBaseY;
             enemy.position.z = roadLength / 2 + Math.random() * roadLength * (initialSpawn ? 1.5 : 0.8);
             enemy.rotation.y = Math.PI;
        }


        // --- Controls Setup ---
        function setupControls() { /* ... (Keep this code as is, just re-adds listeners) ... */
            window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp);
            leftButton.removeEventListener('touchstart', handleTouchStart); leftButton.removeEventListener('touchend', handleTouchEnd); leftButton.removeEventListener('touchcancel', handleTouchEnd);
            rightButton.removeEventListener('touchstart', handleTouchStart); rightButton.removeEventListener('touchend', handleTouchEnd); rightButton.removeEventListener('touchcancel', handleTouchEnd);
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
            leftButton.addEventListener('touchstart', handleTouchStart, { passive: false }); leftButton.addEventListener('touchend', handleTouchEnd); leftButton.addEventListener('touchcancel', handleTouchEnd);
            rightButton.addEventListener('touchstart', handleTouchStart, { passive: false }); rightButton.addEventListener('touchend', handleTouchEnd); rightButton.addEventListener('touchcancel', handleTouchEnd);
        }
        // Modified handleKeyDown to include Pause toggle
        function handleKeyDown(event) {
             if (isGameOver) return; // Ignore input if game over

             // Pause Toggle (only if game has started)
             if (event.key.toLowerCase() === 'p' && gameStarted) {
                 togglePause();
                 return; // Don't process movement keys if pausing/unpausing
             }

             // Movement (only if game started AND not paused)
             if (!isPaused && gameStarted) {
                 if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') { moveLeft = true; }
                 else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') { moveRight = true; }
             }
        }
        function handleKeyUp(event) { /* ... (Keep this code as is) ... */
             // Only affects movement, no need to check pause state here
            if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') { moveLeft = false; }
            else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') { moveRight = false; }
        }
        function handleTouchStart(e) { /* ... (Keep touch controls as is, only active when not paused/gameover) ... */
            if (!isGameOver && !isPaused && gameStarted) { e.preventDefault(); if (e.currentTarget.id === 'left-button') { moveLeft = true; } else if (e.currentTarget.id === 'right-button') { moveRight = true; } }
        }
        function handleTouchEnd(e) { /* ... (Keep touch controls as is) ... */
            e.preventDefault(); if (e.currentTarget.id === 'left-button') { moveLeft = false; } else if (e.currentTarget.id === 'right-button') { moveRight = false; }
        }
        // --- End Controls ---

        // --- Point Reset ---
        function resetPointPosition(point, initial = false) { /* ... (Keep this code as is) ... */
            const laneWidth = roadWidth / 2 - kerbWidth - pointRadius * 2;
            point.position.x = (Math.random() * 2 - 1) * laneWidth;
            point.position.y = pointRadius + 0.01;
            if (initial) { point.position.z = Math.random() * roadLength - roadLength / 2; }
            else { point.position.z = roadLength / 2 + Math.random() * roadLength * 0.5; }
            point.visible = true;
        }

        // --- UI Updates ---
        function updateScoreDisplay() { scoreElement.textContent = `Score: ${score}`; }
        function updateLevelDisplay() { levelElement.textContent = `Level: ${currentLevel}`; }
        function showVihanMessage(message, duration = vihanMessageDuration) { /* ... (Keep this code as is) ... */
             if (vihanMessageTimeoutId) clearTimeout(vihanMessageTimeoutId);
             vihanMessageArea.textContent = message; vihanMessageArea.style.display = 'block';
             requestAnimationFrame(() => { requestAnimationFrame(() => { vihanMessageArea.style.opacity = '1'; }); });
             vihanMessageTimeoutId = setTimeout(() => { vihanMessageArea.style.opacity = '0'; setTimeout(() => { if (vihanMessageArea.style.opacity === '0') { vihanMessageArea.style.display = 'none'; } }, 500); }, duration);
        }
        function startTipsRotation() { /* ... (Keep this code as is) ... */
             if (tipsIntervalId) clearInterval(tipsIntervalId);
             currentTipIndex = Math.floor(Math.random() * tips.length);
             tipsArea.textContent = tips[currentTipIndex]; tipsArea.style.opacity = '1';
             tipsIntervalId = setInterval(() => { currentTipIndex = (currentTipIndex + 1) % tips.length; tipsArea.style.opacity = '0'; setTimeout(() => { tipsArea.textContent = tips[currentTipIndex]; tipsArea.style.opacity = '1'; }, 300); }, tipsIntervalDuration);
        }
        function stopTipsRotation() { /* ... (Keep this code as is) ... */
            if (tipsIntervalId) clearInterval(tipsIntervalId); tipsIntervalId = null; tipsArea.style.opacity = '0';
        }


        // --- Window Resize ---
        function onWindowResize() { /* ... (Keep this code as is) ... */
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Level Up Logic ---
        function checkLevelUp() { /* ... (Keep this code as is) ... */
            if (score >= currentLevelScoreThreshold) {
                currentLevel++; currentLevelScoreThreshold += scoreThresholdIncrement * (1 + (currentLevel-1)*0.5);
                driveSpeed += speedIncrement; maxActiveEnemies = Math.min(maxTotalEnemies, 1 + (currentLevel - 1) * enemiesPerLevel);
                console.log(`Level Up! Lvl: ${currentLevel}, Spd: ${driveSpeed.toFixed(2)}, Enemies: ${maxActiveEnemies}, Next Score: ${Math.round(currentLevelScoreThreshold)}`);
                updateLevelDisplay(); playSound('levelUp'); showVihanMessage(positiveMessages[Math.floor(Math.random() * positiveMessages.length)]);
                 const enemiesToSpawn = maxActiveEnemies - enemyCars.length;
                 for (let i = 0; i < enemiesToSpawn; i++) { spawnEnemyCar(); }
            }
        }

        // --- Game Over ---
        function triggerGameOver() {
            if (isGameOver) return;
             isGameOver = true;
             isPaused = false; // Ensure not paused
             playSound('collision');
             stopTipsRotation();
             stopBackgroundMusic(); // Stop music

             // Stop animation loop FIRST
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }

             // Hide in-game UI and controls
             uiContainer.style.display = 'none';
             leftButton.style.display = 'none';
             rightButton.style.display = 'none';
             pauseButton.style.display = 'none'; // Hide pause button
             pauseScreen.style.display = 'none'; // Hide pause screen if it was open

             // Show Game Over Screen
             const randomCrashMsg = crashMessages[Math.floor(Math.random() * crashMessages.length)];
             gameOverMessageElement.textContent = randomCrashMsg;
             gameOverScreen.style.display = 'flex'; // Show the game over overlay

             console.log("Game Over Triggered!");
        }

        // --- Animation Loop ---
        function animate() {
             // Stop loop if game over OR paused
             if (isGameOver || isPaused) {
                  if (animationFrameId) { // Ensure ID is cleared if paused/game over happens mid-frame
                      cancelAnimationFrame(animationFrameId);
                      animationFrameId = null;
                  }
                 return;
             }

             animationFrameId = requestAnimationFrame(animate);

             const deltaZ = driveSpeed;

            // --- Scenery, Points, Enemy Movement --- (Keep this logic as is)
            roadLines.forEach(line => { line.position.z -= deltaZ; if (line.position.z < -roadLength / 2) { line.position.z += roadLength; } });
            buildings.forEach(building => { building.position.z -= deltaZ; if (building.position.z < -roadLength / 2 - building.geometry.parameters.depth / 2) { building.position.z += roadLength + Math.random() * buildingSpacing * 2; const sideSign = Math.sign(building.position.x); const xOffset = roadWidth / 2 + kerbWidth + 1 + Math.random() * 5 + building.geometry.parameters.width / 2; building.position.x = sideSign * xOffset; } });
            streetLights.forEach(light => { light.position.z -= deltaZ; if (light.position.z < -roadLength / 2) { light.position.z += roadLength + Math.random() * lightSpacing * 2; } });
            trafficLights.forEach(light => { light.position.z -= deltaZ; if (light.position.z < -roadLength / 2) { light.position.z += roadLength * 1.5 + Math.random() * roadLength; } });
            points.forEach(point => { if (!point.visible) return; point.position.z -= deltaZ; if (point.position.z < -roadLength / 2) { resetPointPosition(point); } });
            enemyCars.forEach(enemy => { if (!enemy || !enemy.visible) return; enemy.position.z -= enemy.userData.speed; if (enemy.position.z < -roadLength / 2 - 20) { resetEnemyPosition(enemy); } });


            // --- Player Car Controls & Camera --- (Keep this logic as is)
             if (carModel && carBaseY > 0) {
                 let maxBounds = roadWidth / 2 - kerbWidth - 0.1;
                 try { playerBox.setFromObject(carModel); const carHalfWidth = (playerBox.max.x - playerBox.min.x) / 2; maxBounds = roadWidth / 2 - kerbWidth - carHalfWidth - 0.1; } catch(e) { /* Ignore */ }
                 if (moveLeft && carModel.position.x > -maxBounds) { carModel.position.x -= carMoveSpeed; }
                 if (moveRight && carModel.position.x < maxBounds) { carModel.position.x += carMoveSpeed; }
                 carModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, carModel.position.x));
                 playerBox.setFromObject(carModel); // Update box AFTER moving
                 const targetCameraX = carModel.position.x * 0.5;
                 camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                 camera.lookAt(carModel.position.x, carBaseY + 1, carModel.position.z + 5);
             }

             // --- Collision Detection --- (Keep this logic as is)
             if (carModel && !isGameOver) { // Extra check for isGameOver
                 points.forEach(point => { if (!point.visible) return; pointBox.setFromObject(point); if (playerBox.intersectsBox(pointBox)) { score += pointValue; updateScoreDisplay(); playSound('point'); point.visible = false; resetPointPosition(point); checkLevelUp(); } });
                 for (const enemy of enemyCars) { if (!enemy || !enemy.visible) continue; enemyBox.setFromObject(enemy); if (playerBox.intersectsBox(enemyBox)) { triggerGameOver(); break; } }
             }

            // --- Render ---
            renderer.render(scene, camera);
        } // End animate()

    </script>
</body>
</html>
